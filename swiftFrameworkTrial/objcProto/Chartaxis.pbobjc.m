// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chartaxis.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Chartaxis.pbobjc.h"
 #import "Titleelement.pbobjc.h"
 #import "Horizontalaligntype.pbobjc.h"
 #import "Positionelement.pbobjc.h"
 #import "Properties.pbobjc.h"
 #import "Textbody.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChartaxisRoot

@implementation ChartaxisRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ChartaxisRoot_FileDescriptor

static GPBFileDescriptor *ChartaxisRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - ChartAxis

@implementation ChartAxis

@dynamic hasCategory, category;
@dynamic hasValue, value;
@dynamic hasDate, date;
@dynamic hasSeries, series;

typedef struct ChartAxis__storage_ {
  uint32_t _has_storage_[1];
  ChartAxis_CategoryAxis *category;
  ChartAxis_ValueAxis *value;
  ChartAxis_DateAxis *date;
  ChartAxis_SeriesAxis *series;
} ChartAxis__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_CategoryAxis),
        .number = ChartAxis_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_ValueAxis),
        .number = ChartAxis_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_DateAxis),
        .number = ChartAxis_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "series",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_SeriesAxis),
        .number = ChartAxis_FieldNumber_Series,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChartAxis__storage_, series),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChartAxis_AxisDetails

@implementation ChartAxis_AxisDetails

@dynamic hasAxisId, axisId;
@dynamic hasAxPos, axPos;
@dynamic hasCrossAxisId, crossAxisId;
@dynamic hasScaling, scaling;
@dynamic hasCross, cross;
@dynamic hasTitle, title;
@dynamic hasMajorGrid, majorGrid;
@dynamic hasMinorGrid, minorGrid;
@dynamic hasMajorTickMark, majorTickMark;
@dynamic hasMinorTickMark, minorTickMark;
@dynamic hasLabelPos, labelPos;
@dynamic hasProps, props;
@dynamic hasTextBody, textBody;
@dynamic hasHidden, hidden;

typedef struct ChartAxis_AxisDetails__storage_ {
  uint32_t _has_storage_[1];
  PositionElement axPos;
  ChartAxis_AxisDetails_TickMarkType majorTickMark;
  ChartAxis_AxisDetails_TickMarkType minorTickMark;
  ChartAxis_AxisDetails_LabelPos labelPos;
  NSString *axisId;
  NSString *crossAxisId;
  ChartAxis_AxisDetails_Scaling *scaling;
  ChartAxis_AxisDetails_Cross *cross;
  TitleElement *title;
  Properties *majorGrid;
  Properties *minorGrid;
  Properties *props;
  TextBody *textBody;
} ChartAxis_AxisDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "axisId",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_FieldNumber_AxisId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, axisId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "axPos",
        .dataTypeSpecific.enumDescFunc = PositionElement_EnumDescriptor,
        .number = ChartAxis_AxisDetails_FieldNumber_AxPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, axPos),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "crossAxisId",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_FieldNumber_CrossAxisId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, crossAxisId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scaling",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails_Scaling),
        .number = ChartAxis_AxisDetails_FieldNumber_Scaling,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, scaling),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cross",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails_Cross),
        .number = ChartAxis_AxisDetails_FieldNumber_Cross,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, cross),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = GPBStringifySymbol(TitleElement),
        .number = ChartAxis_AxisDetails_FieldNumber_Title,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "majorGrid",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = ChartAxis_AxisDetails_FieldNumber_MajorGrid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, majorGrid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "minorGrid",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = ChartAxis_AxisDetails_FieldNumber_MinorGrid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, minorGrid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "majorTickMark",
        .dataTypeSpecific.enumDescFunc = ChartAxis_AxisDetails_TickMarkType_EnumDescriptor,
        .number = ChartAxis_AxisDetails_FieldNumber_MajorTickMark,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, majorTickMark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "minorTickMark",
        .dataTypeSpecific.enumDescFunc = ChartAxis_AxisDetails_TickMarkType_EnumDescriptor,
        .number = ChartAxis_AxisDetails_FieldNumber_MinorTickMark,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, minorTickMark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "labelPos",
        .dataTypeSpecific.enumDescFunc = ChartAxis_AxisDetails_LabelPos_EnumDescriptor,
        .number = ChartAxis_AxisDetails_FieldNumber_LabelPos,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, labelPos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "props",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = ChartAxis_AxisDetails_FieldNumber_Props,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, props),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textBody",
        .dataTypeSpecific.className = GPBStringifySymbol(TextBody),
        .number = ChartAxis_AxisDetails_FieldNumber_TextBody,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails__storage_, textBody),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_FieldNumber_Hidden,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_AxisDetails class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_AxisDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\006\000\002\005\000\003\013\000\007\t\000\010\t\000\t\r\000\n\r\000\013\010\000\r\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_AxisDetails_TickMarkType

GPBEnumDescriptor *ChartAxis_AxisDetails_TickMarkType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000In\000Out\000Cross\000";
    static const int32_t values[] = {
        ChartAxis_AxisDetails_TickMarkType_None,
        ChartAxis_AxisDetails_TickMarkType_In,
        ChartAxis_AxisDetails_TickMarkType_Out,
        ChartAxis_AxisDetails_TickMarkType_Cross,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_AxisDetails_TickMarkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_AxisDetails_TickMarkType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_AxisDetails_TickMarkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_AxisDetails_TickMarkType_None:
    case ChartAxis_AxisDetails_TickMarkType_In:
    case ChartAxis_AxisDetails_TickMarkType_Out:
    case ChartAxis_AxisDetails_TickMarkType_Cross:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChartAxis_AxisDetails_LabelPos

GPBEnumDescriptor *ChartAxis_AxisDetails_LabelPos_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Nil\000High\000Low\000Nextto\000";
    static const int32_t values[] = {
        ChartAxis_AxisDetails_LabelPos_Nil,
        ChartAxis_AxisDetails_LabelPos_High,
        ChartAxis_AxisDetails_LabelPos_Low,
        ChartAxis_AxisDetails_LabelPos_Nextto,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_AxisDetails_LabelPos)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_AxisDetails_LabelPos_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_AxisDetails_LabelPos_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_AxisDetails_LabelPos_Nil:
    case ChartAxis_AxisDetails_LabelPos_High:
    case ChartAxis_AxisDetails_LabelPos_Low:
    case ChartAxis_AxisDetails_LabelPos_Nextto:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_AxisDetails_Scaling

@implementation ChartAxis_AxisDetails_Scaling

@dynamic hasOrient, orient;
@dynamic hasMin, min;
@dynamic hasMax, max;

typedef struct ChartAxis_AxisDetails_Scaling__storage_ {
  uint32_t _has_storage_[1];
  ChartAxis_AxisDetails_Scaling_Orientation orient;
  float min;
  float max;
} ChartAxis_AxisDetails_Scaling__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orient",
        .dataTypeSpecific.enumDescFunc = ChartAxis_AxisDetails_Scaling_Orientation_EnumDescriptor,
        .number = ChartAxis_AxisDetails_Scaling_FieldNumber_Orient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails_Scaling__storage_, orient),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_Scaling_FieldNumber_Min,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails_Scaling__storage_, min),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_Scaling_FieldNumber_Max,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails_Scaling__storage_, max),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_AxisDetails_Scaling class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_AxisDetails_Scaling__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis_AxisDetails)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_AxisDetails_Scaling_Orientation

GPBEnumDescriptor *ChartAxis_AxisDetails_Scaling_Orientation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Minmax\000Maxmin\000";
    static const int32_t values[] = {
        ChartAxis_AxisDetails_Scaling_Orientation_Minmax,
        ChartAxis_AxisDetails_Scaling_Orientation_Maxmin,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_AxisDetails_Scaling_Orientation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_AxisDetails_Scaling_Orientation_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_AxisDetails_Scaling_Orientation_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_AxisDetails_Scaling_Orientation_Minmax:
    case ChartAxis_AxisDetails_Scaling_Orientation_Maxmin:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_AxisDetails_Cross

@implementation ChartAxis_AxisDetails_Cross

@dynamic hasType, type;
@dynamic hasValue, value;

typedef struct ChartAxis_AxisDetails_Cross__storage_ {
  uint32_t _has_storage_[1];
  ChartAxis_AxisDetails_Cross_CrossType type;
  float value;
} ChartAxis_AxisDetails_Cross__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChartAxis_AxisDetails_Cross_CrossType_EnumDescriptor,
        .number = ChartAxis_AxisDetails_Cross_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails_Cross__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_AxisDetails_Cross_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_AxisDetails_Cross__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_AxisDetails_Cross class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_AxisDetails_Cross__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis_AxisDetails)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_AxisDetails_Cross_CrossType

GPBEnumDescriptor *ChartAxis_AxisDetails_Cross_CrossType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Autozero\000Min\000Max\000Manual\000";
    static const int32_t values[] = {
        ChartAxis_AxisDetails_Cross_CrossType_Autozero,
        ChartAxis_AxisDetails_Cross_CrossType_Min,
        ChartAxis_AxisDetails_Cross_CrossType_Max,
        ChartAxis_AxisDetails_Cross_CrossType_Manual,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_AxisDetails_Cross_CrossType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_AxisDetails_Cross_CrossType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_AxisDetails_Cross_CrossType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_AxisDetails_Cross_CrossType_Autozero:
    case ChartAxis_AxisDetails_Cross_CrossType_Min:
    case ChartAxis_AxisDetails_Cross_CrossType_Max:
    case ChartAxis_AxisDetails_Cross_CrossType_Manual:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_CategoryAxis

@implementation ChartAxis_CategoryAxis

@dynamic hasDetails, details;
@dynamic hasLblAlign, lblAlign;
@dynamic hasLblOffset, lblOffset;
@dynamic hasSkipTickLabel, skipTickLabel;
@dynamic hasSkipTickMark, skipTickMark;

typedef struct ChartAxis_CategoryAxis__storage_ {
  uint32_t _has_storage_[1];
  HorizontalAlignType lblAlign;
  float lblOffset;
  int32_t skipTickLabel;
  int32_t skipTickMark;
  ChartAxis_AxisDetails *details;
} ChartAxis_CategoryAxis__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "details",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails),
        .core.number = ChartAxis_CategoryAxis_FieldNumber_Details,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ChartAxis_CategoryAxis__storage_, details),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = HorizontalAlignType_Left,
        .core.name = "lblAlign",
        .core.dataTypeSpecific.enumDescFunc = HorizontalAlignType_EnumDescriptor,
        .core.number = ChartAxis_CategoryAxis_FieldNumber_LblAlign,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ChartAxis_CategoryAxis__storage_, lblAlign),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueFloat = 0,
        .core.name = "lblOffset",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ChartAxis_CategoryAxis_FieldNumber_LblOffset,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ChartAxis_CategoryAxis__storage_, lblOffset),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeFloat,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "skipTickLabel",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ChartAxis_CategoryAxis_FieldNumber_SkipTickLabel,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ChartAxis_CategoryAxis__storage_, skipTickLabel),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "skipTickMark",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ChartAxis_CategoryAxis_FieldNumber_SkipTickMark,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ChartAxis_CategoryAxis__storage_, skipTickMark),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_CategoryAxis class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ChartAxis_CategoryAxis__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\010\000\003\t\000\004\r\000\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChartAxis_ValueAxis

@implementation ChartAxis_ValueAxis

@dynamic hasDetails, details;
@dynamic hasCrossBetween, crossBetween;
@dynamic hasMajor, major;
@dynamic hasMinor, minor;
@dynamic hasDisplayUnit, displayUnit;

typedef struct ChartAxis_ValueAxis__storage_ {
  uint32_t _has_storage_[1];
  ChartAxis_ValueAxis_CrossBetween crossBetween;
  float major;
  float minor;
  ChartAxis_AxisDetails *details;
  ChartAxis_ValueAxis_DisplayUnit *displayUnit;
} ChartAxis_ValueAxis__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails),
        .number = ChartAxis_ValueAxis_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis__storage_, details),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "crossBetween",
        .dataTypeSpecific.enumDescFunc = ChartAxis_ValueAxis_CrossBetween_EnumDescriptor,
        .number = ChartAxis_ValueAxis_FieldNumber_CrossBetween,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis__storage_, crossBetween),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "major",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_ValueAxis_FieldNumber_Major,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis__storage_, major),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "minor",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_ValueAxis_FieldNumber_Minor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis__storage_, minor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "displayUnit",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_ValueAxis_DisplayUnit),
        .number = ChartAxis_ValueAxis_FieldNumber_DisplayUnit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis__storage_, displayUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_ValueAxis class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_ValueAxis__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\014\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_ValueAxis_CrossBetween

GPBEnumDescriptor *ChartAxis_ValueAxis_CrossBetween_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000Midcat\000";
    static const int32_t values[] = {
        ChartAxis_ValueAxis_CrossBetween_Default,
        ChartAxis_ValueAxis_CrossBetween_Midcat,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_ValueAxis_CrossBetween)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_ValueAxis_CrossBetween_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_ValueAxis_CrossBetween_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_ValueAxis_CrossBetween_Default:
    case ChartAxis_ValueAxis_CrossBetween_Midcat:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_ValueAxis_DisplayUnit

@implementation ChartAxis_ValueAxis_DisplayUnit

@dynamic hasType, type;
@dynamic hasCustom, custom;
@dynamic hasLabel, label;

typedef struct ChartAxis_ValueAxis_DisplayUnit__storage_ {
  uint32_t _has_storage_[1];
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType type;
  float custom;
  TitleElement *label;
} ChartAxis_ValueAxis_DisplayUnit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_EnumDescriptor,
        .number = ChartAxis_ValueAxis_DisplayUnit_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis_DisplayUnit__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "custom",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_ValueAxis_DisplayUnit_FieldNumber_Custom,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis_DisplayUnit__storage_, custom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "label",
        .dataTypeSpecific.className = GPBStringifySymbol(TitleElement),
        .number = ChartAxis_ValueAxis_DisplayUnit_FieldNumber_Label,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_ValueAxis_DisplayUnit__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_ValueAxis_DisplayUnit class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_ValueAxis_DisplayUnit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis_ValueAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType

GPBEnumDescriptor *ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Hundreds\000Thousands\000Tenthousands\000Hun"
        "dredthousands\000Millions\000Tenmillions\000Hundr"
        "edmillions\000Billions\000Trillions\000Custom\000";
    static const int32_t values[] = {
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_None,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundreds,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Thousands,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Tenthousands,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundredthousands,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Millions,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Tenmillions,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundredmillions,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Billions,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Trillions,
        ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Custom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_None:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundreds:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Thousands:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Tenthousands:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundredthousands:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Millions:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Tenmillions:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Hundredmillions:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Billions:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Trillions:
    case ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Custom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_DateAxis

@implementation ChartAxis_DateAxis

@dynamic hasDetails, details;
@dynamic hasLblOffset, lblOffset;
@dynamic hasMajor, major;
@dynamic hasMinor, minor;
@dynamic hasBaseTimeUnit, baseTimeUnit;
@dynamic hasMajorTimeUnit, majorTimeUnit;
@dynamic hasMinorTimeUnit, minorTimeUnit;

typedef struct ChartAxis_DateAxis__storage_ {
  uint32_t _has_storage_[1];
  float lblOffset;
  float major;
  float minor;
  ChartAxis_DateAxis_TimeUnit baseTimeUnit;
  ChartAxis_DateAxis_TimeUnit majorTimeUnit;
  ChartAxis_DateAxis_TimeUnit minorTimeUnit;
  ChartAxis_AxisDetails *details;
} ChartAxis_DateAxis__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails),
        .number = ChartAxis_DateAxis_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, details),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lblOffset",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_DateAxis_FieldNumber_LblOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, lblOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "major",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_DateAxis_FieldNumber_Major,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, major),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "minor",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_DateAxis_FieldNumber_Minor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, minor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "baseTimeUnit",
        .dataTypeSpecific.enumDescFunc = ChartAxis_DateAxis_TimeUnit_EnumDescriptor,
        .number = ChartAxis_DateAxis_FieldNumber_BaseTimeUnit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, baseTimeUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "majorTimeUnit",
        .dataTypeSpecific.enumDescFunc = ChartAxis_DateAxis_TimeUnit_EnumDescriptor,
        .number = ChartAxis_DateAxis_FieldNumber_MajorTimeUnit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, majorTimeUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "minorTimeUnit",
        .dataTypeSpecific.enumDescFunc = ChartAxis_DateAxis_TimeUnit_EnumDescriptor,
        .number = ChartAxis_DateAxis_FieldNumber_MinorTimeUnit,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChartAxis_DateAxis__storage_, minorTimeUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_DateAxis class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_DateAxis__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\t\000\005\014\000\006\r\000\007\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ChartAxis_DateAxis_TimeUnit

GPBEnumDescriptor *ChartAxis_DateAxis_TimeUnit_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Days\000Months\000Years\000";
    static const int32_t values[] = {
        ChartAxis_DateAxis_TimeUnit_Days,
        ChartAxis_DateAxis_TimeUnit_Months,
        ChartAxis_DateAxis_TimeUnit_Years,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChartAxis_DateAxis_TimeUnit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChartAxis_DateAxis_TimeUnit_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChartAxis_DateAxis_TimeUnit_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChartAxis_DateAxis_TimeUnit_Days:
    case ChartAxis_DateAxis_TimeUnit_Months:
    case ChartAxis_DateAxis_TimeUnit_Years:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChartAxis_SeriesAxis

@implementation ChartAxis_SeriesAxis

@dynamic hasDetails, details;
@dynamic hasSkipTickLabel, skipTickLabel;
@dynamic hasSkipTickMark, skipTickMark;

typedef struct ChartAxis_SeriesAxis__storage_ {
  uint32_t _has_storage_[1];
  int32_t skipTickLabel;
  int32_t skipTickMark;
  ChartAxis_AxisDetails *details;
} ChartAxis_SeriesAxis__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartAxis_AxisDetails),
        .number = ChartAxis_SeriesAxis_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChartAxis_SeriesAxis__storage_, details),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skipTickLabel",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_SeriesAxis_FieldNumber_SkipTickLabel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChartAxis_SeriesAxis__storage_, skipTickLabel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skipTickMark",
        .dataTypeSpecific.className = NULL,
        .number = ChartAxis_SeriesAxis_FieldNumber_SkipTickMark,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChartAxis_SeriesAxis__storage_, skipTickMark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChartAxis_SeriesAxis class]
                                     rootClass:[ChartaxisRoot class]
                                          file:ChartaxisRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChartAxis_SeriesAxis__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\r\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChartAxis)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
