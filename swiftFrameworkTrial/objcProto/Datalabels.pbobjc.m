// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datalabels.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Datalabels.pbobjc.h"
 #import "Textbody.pbobjc.h"
 #import "Chartline.pbobjc.h"
 #import "Properties.pbobjc.h"
 #import "Manuallayout.pbobjc.h"
 #import "Charttext.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - DatalabelsRoot

@implementation DatalabelsRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DatalabelsRoot_FileDescriptor

static GPBFileDescriptor *DatalabelsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - DataLabels

@implementation DataLabels

@dynamic hasDetails, details;
@dynamic labelsArray, labelsArray_Count;
@dynamic hasLeaderLine, leaderLine;

typedef struct DataLabels__storage_ {
  uint32_t _has_storage_[1];
  DataLabels_DataLabelDetails *details;
  NSMutableArray *labelsArray;
  ChartLine *leaderLine;
} DataLabels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(DataLabels_DataLabelDetails),
        .number = DataLabels_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataLabels__storage_, details),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DataLabels_DataLabel),
        .number = DataLabels_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DataLabels__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leaderLine",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartLine),
        .number = DataLabels_FieldNumber_LeaderLine,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DataLabels__storage_, leaderLine),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataLabels class]
                                     rootClass:[DatalabelsRoot class]
                                          file:DatalabelsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataLabels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DataLabels_DataLabelDetails

@implementation DataLabels_DataLabelDetails

@dynamic hasPos, pos;
@dynamic hasBubbleSize, bubbleSize;
@dynamic hasCategoryName, categoryName;
@dynamic hasLegendKey, legendKey;
@dynamic hasValue, value;
@dynamic hasPercent, percent;
@dynamic hasSeriesName, seriesName;
@dynamic hasLeaderLine, leaderLine;
@dynamic hasSep, sep;
@dynamic hasTextBody, textBody;
@dynamic hasProps, props;

typedef struct DataLabels_DataLabelDetails__storage_ {
  uint32_t _has_storage_[1];
  DataLabels_DataLabelDetails_DataLabelPosition pos;
  DataLabels_DataLabelDetails_Separator *sep;
  TextBody *textBody;
  Properties *props;
} DataLabels_DataLabelDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pos",
        .dataTypeSpecific.enumDescFunc = DataLabels_DataLabelDetails_DataLabelPosition_EnumDescriptor,
        .number = DataLabels_DataLabelDetails_FieldNumber_Pos,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails__storage_, pos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bubbleSize",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_BubbleSize,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "categoryName",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_CategoryName,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "legendKey",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_LegendKey,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_Value,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "percent",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_Percent,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "seriesName",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_SeriesName,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "leaderLine",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_FieldNumber_LeaderLine,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sep",
        .dataTypeSpecific.className = GPBStringifySymbol(DataLabels_DataLabelDetails_Separator),
        .number = DataLabels_DataLabelDetails_FieldNumber_Sep,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails__storage_, sep),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textBody",
        .dataTypeSpecific.className = GPBStringifySymbol(TextBody),
        .number = DataLabels_DataLabelDetails_FieldNumber_TextBody,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails__storage_, textBody),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "props",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = DataLabels_DataLabelDetails_FieldNumber_Props,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails__storage_, props),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataLabels_DataLabelDetails class]
                                     rootClass:[DatalabelsRoot class]
                                          file:DatalabelsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataLabels_DataLabelDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\n\000\003\014\000\004\t\000\007\n\000\010\n\000\n\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DataLabels)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum DataLabels_DataLabelDetails_DataLabelPosition

GPBEnumDescriptor *DataLabels_DataLabelDetails_DataLabelPosition_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Bestfit\000Bottom\000Center\000Inbase\000Inend\000Left\000"
        "Outend\000Right\000Top\000";
    static const int32_t values[] = {
        DataLabels_DataLabelDetails_DataLabelPosition_Bestfit,
        DataLabels_DataLabelDetails_DataLabelPosition_Bottom,
        DataLabels_DataLabelDetails_DataLabelPosition_Center,
        DataLabels_DataLabelDetails_DataLabelPosition_Inbase,
        DataLabels_DataLabelDetails_DataLabelPosition_Inend,
        DataLabels_DataLabelDetails_DataLabelPosition_Left,
        DataLabels_DataLabelDetails_DataLabelPosition_Outend,
        DataLabels_DataLabelDetails_DataLabelPosition_Right,
        DataLabels_DataLabelDetails_DataLabelPosition_Top,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DataLabels_DataLabelDetails_DataLabelPosition)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DataLabels_DataLabelDetails_DataLabelPosition_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DataLabels_DataLabelDetails_DataLabelPosition_IsValidValue(int32_t value__) {
  switch (value__) {
    case DataLabels_DataLabelDetails_DataLabelPosition_Bestfit:
    case DataLabels_DataLabelDetails_DataLabelPosition_Bottom:
    case DataLabels_DataLabelDetails_DataLabelPosition_Center:
    case DataLabels_DataLabelDetails_DataLabelPosition_Inbase:
    case DataLabels_DataLabelDetails_DataLabelPosition_Inend:
    case DataLabels_DataLabelDetails_DataLabelPosition_Left:
    case DataLabels_DataLabelDetails_DataLabelPosition_Outend:
    case DataLabels_DataLabelDetails_DataLabelPosition_Right:
    case DataLabels_DataLabelDetails_DataLabelPosition_Top:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DataLabels_DataLabelDetails_Separator

@implementation DataLabels_DataLabelDetails_Separator

@dynamic hasType, type;
@dynamic hasT, t;

typedef struct DataLabels_DataLabelDetails_Separator__storage_ {
  uint32_t _has_storage_[1];
  DataLabels_DataLabelDetails_Separator_SeparatorType type;
  NSString *t;
} DataLabels_DataLabelDetails_Separator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DataLabels_DataLabelDetails_Separator_SeparatorType_EnumDescriptor,
        .number = DataLabels_DataLabelDetails_Separator_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails_Separator__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = DataLabels_DataLabelDetails_Separator_FieldNumber_T,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DataLabels_DataLabelDetails_Separator__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataLabels_DataLabelDetails_Separator class]
                                     rootClass:[DatalabelsRoot class]
                                          file:DatalabelsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataLabels_DataLabelDetails_Separator__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DataLabels_DataLabelDetails)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum DataLabels_DataLabelDetails_Separator_SeparatorType

GPBEnumDescriptor *DataLabels_DataLabelDetails_Separator_SeparatorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Comma\000Semicolon\000Period\000Newline\000Space\000Any"
        "\000";
    static const int32_t values[] = {
        DataLabels_DataLabelDetails_Separator_SeparatorType_Comma,
        DataLabels_DataLabelDetails_Separator_SeparatorType_Semicolon,
        DataLabels_DataLabelDetails_Separator_SeparatorType_Period,
        DataLabels_DataLabelDetails_Separator_SeparatorType_Newline,
        DataLabels_DataLabelDetails_Separator_SeparatorType_Space,
        DataLabels_DataLabelDetails_Separator_SeparatorType_Any,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DataLabels_DataLabelDetails_Separator_SeparatorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DataLabels_DataLabelDetails_Separator_SeparatorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DataLabels_DataLabelDetails_Separator_SeparatorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Comma:
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Semicolon:
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Period:
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Newline:
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Space:
    case DataLabels_DataLabelDetails_Separator_SeparatorType_Any:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DataLabels_DataLabel

@implementation DataLabels_DataLabel

@dynamic hasDetails, details;
@dynamic hasLayout, layout;
@dynamic hasTx, tx;

typedef struct DataLabels_DataLabel__storage_ {
  uint32_t _has_storage_[1];
  DataLabels_DataLabelDetails *details;
  ManualLayout *layout;
  ChartText *tx;
} DataLabels_DataLabel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(DataLabels_DataLabelDetails),
        .number = DataLabels_DataLabel_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataLabels_DataLabel__storage_, details),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layout",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualLayout),
        .number = DataLabels_DataLabel_FieldNumber_Layout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DataLabels_DataLabel__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tx",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartText),
        .number = DataLabels_DataLabel_FieldNumber_Tx,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DataLabels_DataLabel__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataLabels_DataLabel class]
                                     rootClass:[DatalabelsRoot class]
                                          file:DatalabelsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataLabels_DataLabel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DataLabels)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
