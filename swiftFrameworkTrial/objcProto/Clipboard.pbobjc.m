// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: build/clipboard.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Clipboard.pbobjc.h"
 #import "Shapenodetype.pbobjc.h"
 #import "Picproperties.pbobjc.h"
 #import "Tablestyle.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ClipboardRoot

@implementation ClipboardRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ClipboardRoot_FileDescriptor

static GPBFileDescriptor *ClipboardRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - ClipBoard

@implementation ClipBoard

@dynamic clipsArray, clipsArray_Count;

typedef struct ClipBoard__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *clipsArray;
} ClipBoard__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clipsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_Clip),
        .number = ClipBoard_FieldNumber_ClipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard__storage_, clipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_Clip

@implementation ClipBoard_Clip

@dynamic hasData_p, data_p;
@dynamic hasDetail, detail;

typedef struct ClipBoard_Clip__storage_ {
  uint32_t _has_storage_[1];
  ClipBoard_ClipData *data_p;
  ClipBoard_ClipDetail *detail;
} ClipBoard_Clip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData),
        .number = ClipBoard_Clip_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_Clip__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipDetail),
        .number = ClipBoard_Clip_FieldNumber_Detail,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_Clip__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_Clip class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_Clip__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipDetail

@implementation ClipBoard_ClipDetail

@dynamic hasDocId, docId;
@dynamic hasOwner, owner;
@dynamic hasSlideId, slideId;

typedef struct ClipBoard_ClipDetail__storage_ {
  uint32_t _has_storage_[1];
  NSString *docId;
  NSString *owner;
  NSString *slideId;
} ClipBoard_ClipDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "docId",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipDetail_FieldNumber_DocId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipDetail__storage_, docId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipDetail_FieldNumber_Owner,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_ClipDetail__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slideId",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipDetail_FieldNumber_SlideId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClipBoard_ClipDetail__storage_, slideId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipDetail class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipData

@implementation ClipBoard_ClipData

@dynamic hasType, type;
@dynamic hasShape, shape;
@dynamic slidesArray, slidesArray_Count;
@dynamic mastersArray, mastersArray_Count;
@dynamic hasText, text;

typedef struct ClipBoard_ClipData__storage_ {
  uint32_t _has_storage_[1];
  ClipBoard_ClipData_ClipType type;
  ClipBoard_ClipData_NodeValue *shape;
  NSMutableArray *slidesArray;
  NSMutableArray *mastersArray;
  ClipBoard_ClipData_NodeValue *text;
} ClipBoard_ClipData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ClipBoard_ClipData_ClipType_EnumDescriptor,
        .number = ClipBoard_ClipData_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shape",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_FieldNumber_Shape,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slidesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_SlideNode),
        .number = ClipBoard_ClipData_FieldNumber_SlidesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData__storage_, slidesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mastersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_MasterNode),
        .number = ClipBoard_ClipData_FieldNumber_MastersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData__storage_, mastersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_FieldNumber_Text,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ClipBoard_ClipData_ClipType

GPBEnumDescriptor *ClipBoard_ClipData_ClipType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Shape\000Slide\000Master\000Text\000";
    static const int32_t values[] = {
        ClipBoard_ClipData_ClipType_Shape,
        ClipBoard_ClipData_ClipType_Slide,
        ClipBoard_ClipData_ClipType_Master,
        ClipBoard_ClipData_ClipType_Text,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClipBoard_ClipData_ClipType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClipBoard_ClipData_ClipType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClipBoard_ClipData_ClipType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClipBoard_ClipData_ClipType_Shape:
    case ClipBoard_ClipData_ClipType_Slide:
    case ClipBoard_ClipData_ClipType_Master:
    case ClipBoard_ClipData_ClipType_Text:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ClipBoard_ClipData_NodeValue

@implementation ClipBoard_ClipData_NodeValue

@dynamic hasId_p, id_p;
@dynamic dependsArray, dependsArray_Count;
@dynamic hasRelated, related;

typedef struct ClipBoard_ClipData_NodeValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSMutableArray *dependsArray;
  ClipBoard_ClipData_RelatedData *related;
} ClipBoard_ClipData_NodeValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipData_NodeValue_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_NodeValue__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dependsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_Dependence),
        .number = ClipBoard_ClipData_NodeValue_FieldNumber_DependsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_NodeValue__storage_, dependsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "related",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_RelatedData),
        .number = ClipBoard_ClipData_NodeValue_FieldNumber_Related,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_NodeValue__storage_, related),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData_NodeValue class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData_NodeValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard_ClipData)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipData_RelatedData

@implementation ClipBoard_ClipData_RelatedData

@dynamic tableStylesArray, tableStylesArray_Count;

typedef struct ClipBoard_ClipData_RelatedData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tableStylesArray;
} ClipBoard_ClipData_RelatedData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tableStylesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TableStyle),
        .number = ClipBoard_ClipData_RelatedData_FieldNumber_TableStylesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_RelatedData__storage_, tableStylesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData_RelatedData class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData_RelatedData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000tableStyles\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard_ClipData)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipData_Dependence

@implementation ClipBoard_ClipData_Dependence

@dynamic hasType, type;
@dynamic hasId_p, id_p;
@dynamic hasDependentId, dependentId;
@dynamic hasPicProps, picProps;
@dynamic hasIsSpreadsheet, isSpreadsheet;

typedef struct ClipBoard_ClipData_Dependence__storage_ {
  uint32_t _has_storage_[1];
  ShapeNodeType type;
  NSString *id_p;
  NSString *dependentId;
  PicProperties *picProps;
} ClipBoard_ClipData_Dependence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ShapeNodeType_EnumDescriptor,
        .number = ClipBoard_ClipData_Dependence_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_Dependence__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipData_Dependence_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_Dependence__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dependentId",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipData_Dependence_FieldNumber_DependentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_Dependence__storage_, dependentId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "picProps",
        .dataTypeSpecific.className = GPBStringifySymbol(PicProperties),
        .number = ClipBoard_ClipData_Dependence_FieldNumber_PicProps,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_Dependence__storage_, picProps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isSpreadsheet",
        .dataTypeSpecific.className = NULL,
        .number = ClipBoard_ClipData_Dependence_FieldNumber_IsSpreadsheet,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData_Dependence class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData_Dependence__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\013\000\004\010\000\005\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard_ClipData)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipData_SlideNode

@implementation ClipBoard_ClipData_SlideNode

@dynamic hasSlide, slide;
@dynamic hasLayout, layout;

typedef struct ClipBoard_ClipData_SlideNode__storage_ {
  uint32_t _has_storage_[1];
  ClipBoard_ClipData_NodeValue *slide;
  ClipBoard_ClipData_NodeValue *layout;
} ClipBoard_ClipData_SlideNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slide",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_SlideNode_FieldNumber_Slide,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_SlideNode__storage_, slide),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layout",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_SlideNode_FieldNumber_Layout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_SlideNode__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData_SlideNode class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData_SlideNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard_ClipData)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipBoard_ClipData_MasterNode

@implementation ClipBoard_ClipData_MasterNode

@dynamic hasMaster, master;
@dynamic layoutsArray, layoutsArray_Count;

typedef struct ClipBoard_ClipData_MasterNode__storage_ {
  uint32_t _has_storage_[1];
  ClipBoard_ClipData_NodeValue *master;
  NSMutableArray *layoutsArray;
} ClipBoard_ClipData_MasterNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "master",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_MasterNode_FieldNumber_Master,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_MasterNode__storage_, master),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layoutsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClipBoard_ClipData_NodeValue),
        .number = ClipBoard_ClipData_MasterNode_FieldNumber_LayoutsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipBoard_ClipData_MasterNode__storage_, layoutsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipBoard_ClipData_MasterNode class]
                                     rootClass:[ClipboardRoot class]
                                          file:ClipboardRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipBoard_ClipData_MasterNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClipBoard_ClipData)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
