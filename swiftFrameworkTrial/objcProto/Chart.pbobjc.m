// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chart.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Chart.pbobjc.h"
 #import "Colormap.pbobjc.h"
 #import "Titleelement.pbobjc.h"
 #import "Manuallayout.pbobjc.h"
 #import "Properties.pbobjc.h"
 #import "Textbody.pbobjc.h"
 #import "Positionelement.pbobjc.h"
 #import "Plotarea.pbobjc.h"
 #import "Chartstyle.pbobjc.h"
 #import "Picturevalue.pbobjc.h"
 #import "Chartshape.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChartRoot

@implementation ChartRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ChartRoot_FileDescriptor

static GPBFileDescriptor *ChartRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Chart

@implementation Chart

@dynamic hasObj, obj;
@dynamic hasColorMap, colorMap;
@dynamic hasTextBody, textBody;
@dynamic hasProps, props;
@dynamic hasStyle, style;
@dynamic hasStyleNumber, styleNumber;
@dynamic hasPicture, picture;
@dynamic hasChartShape, chartShape;

typedef struct Chart__storage_ {
  uint32_t _has_storage_[1];
  int32_t styleNumber;
  Chart_ChartObj *obj;
  ColorMap *colorMap;
  TextBody *textBody;
  Properties *props;
  ChartStyle *style;
  PictureValue *picture;
  ChartShape *chartShape;
} Chart__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "obj",
        .dataTypeSpecific.className = GPBStringifySymbol(Chart_ChartObj),
        .number = Chart_FieldNumber_Obj,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Chart__storage_, obj),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "colorMap",
        .dataTypeSpecific.className = GPBStringifySymbol(ColorMap),
        .number = Chart_FieldNumber_ColorMap,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Chart__storage_, colorMap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textBody",
        .dataTypeSpecific.className = GPBStringifySymbol(TextBody),
        .number = Chart_FieldNumber_TextBody,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Chart__storage_, textBody),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "props",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = Chart_FieldNumber_Props,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Chart__storage_, props),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartStyle),
        .number = Chart_FieldNumber_Style,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Chart__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "styleNumber",
        .dataTypeSpecific.className = NULL,
        .number = Chart_FieldNumber_StyleNumber,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Chart__storage_, styleNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "picture",
        .dataTypeSpecific.className = GPBStringifySymbol(PictureValue),
        .number = Chart_FieldNumber_Picture,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Chart__storage_, picture),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chartShape",
        .dataTypeSpecific.className = GPBStringifySymbol(ChartShape),
        .number = Chart_FieldNumber_ChartShape,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Chart__storage_, chartShape),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Chart class]
                                     rootClass:[ChartRoot class]
                                          file:ChartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Chart__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\010\000\003\010\000\006\013\000\010\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Chart_ChartObj

@implementation Chart_ChartObj

@dynamic hasTitle, title;
@dynamic hasLegend, legend;
@dynamic hasPlotArea, plotArea;
@dynamic hasDispBlankAs, dispBlankAs;
@dynamic hasPlotVisible, plotVisible;

typedef struct Chart_ChartObj__storage_ {
  uint32_t _has_storage_[1];
  Chart_ChartObj_DisplayBlank dispBlankAs;
  TitleElement *title;
  Chart_ChartObj_Legend *legend;
  PlotArea *plotArea;
} Chart_ChartObj__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = GPBStringifySymbol(TitleElement),
        .number = Chart_ChartObj_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Chart_ChartObj__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "legend",
        .dataTypeSpecific.className = GPBStringifySymbol(Chart_ChartObj_Legend),
        .number = Chart_ChartObj_FieldNumber_Legend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Chart_ChartObj__storage_, legend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "plotArea",
        .dataTypeSpecific.className = GPBStringifySymbol(PlotArea),
        .number = Chart_ChartObj_FieldNumber_PlotArea,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Chart_ChartObj__storage_, plotArea),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dispBlankAs",
        .dataTypeSpecific.enumDescFunc = Chart_ChartObj_DisplayBlank_EnumDescriptor,
        .number = Chart_ChartObj_FieldNumber_DispBlankAs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Chart_ChartObj__storage_, dispBlankAs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "plotVisible",
        .dataTypeSpecific.className = NULL,
        .number = Chart_ChartObj_FieldNumber_PlotVisible,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Chart_ChartObj class]
                                     rootClass:[ChartRoot class]
                                          file:ChartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Chart_ChartObj__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\010\000\004\013\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Chart)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Chart_ChartObj_DisplayBlank

GPBEnumDescriptor *Chart_ChartObj_DisplayBlank_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Span\000Gap\000Zero\000";
    static const int32_t values[] = {
        Chart_ChartObj_DisplayBlank_Span,
        Chart_ChartObj_DisplayBlank_Gap,
        Chart_ChartObj_DisplayBlank_Zero,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Chart_ChartObj_DisplayBlank)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Chart_ChartObj_DisplayBlank_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Chart_ChartObj_DisplayBlank_IsValidValue(int32_t value__) {
  switch (value__) {
    case Chart_ChartObj_DisplayBlank_Span:
    case Chart_ChartObj_DisplayBlank_Gap:
    case Chart_ChartObj_DisplayBlank_Zero:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Chart_ChartObj_Legend

@implementation Chart_ChartObj_Legend

@dynamic hasPos, pos;
@dynamic hasProps, props;
@dynamic hasOverlay, overlay;
@dynamic hasLayout, layout;
@dynamic hasTextBody, textBody;

typedef struct Chart_ChartObj_Legend__storage_ {
  uint32_t _has_storage_[1];
  PositionElement pos;
  Properties *props;
  ManualLayout *layout;
  TextBody *textBody;
} Chart_ChartObj_Legend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pos",
        .dataTypeSpecific.enumDescFunc = PositionElement_EnumDescriptor,
        .number = Chart_ChartObj_Legend_FieldNumber_Pos,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Chart_ChartObj_Legend__storage_, pos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "props",
        .dataTypeSpecific.className = GPBStringifySymbol(Properties),
        .number = Chart_ChartObj_Legend_FieldNumber_Props,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Chart_ChartObj_Legend__storage_, props),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "overlay",
        .dataTypeSpecific.className = NULL,
        .number = Chart_ChartObj_Legend_FieldNumber_Overlay,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "layout",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualLayout),
        .number = Chart_ChartObj_Legend_FieldNumber_Layout,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Chart_ChartObj_Legend__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textBody",
        .dataTypeSpecific.className = GPBStringifySymbol(TextBody),
        .number = Chart_ChartObj_Legend_FieldNumber_TextBody,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Chart_ChartObj_Legend__storage_, textBody),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Chart_ChartObj_Legend class]
                                     rootClass:[ChartRoot class]
                                          file:ChartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Chart_ChartObj_Legend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Chart_ChartObj)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
