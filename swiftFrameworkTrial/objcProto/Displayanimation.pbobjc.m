// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: displayanimation.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Displayanimation.pbobjc.h"
 #import "Presetshapegeometry.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - DisplayanimationRoot

@implementation DisplayanimationRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DisplayanimationRoot_FileDescriptor

static GPBFileDescriptor *DisplayanimationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - DisplayAnimation

@implementation DisplayAnimation

@dynamic hasType, type;
@dynamic hasBlinds, blinds;
@dynamic hasChecker, checker;
@dynamic hasComb, comb;
@dynamic hasCover, cover;
@dynamic hasCut, cut;
@dynamic hasFade, fade;
@dynamic hasPull, pull;
@dynamic hasPush, push;
@dynamic hasRandombar, randombar;
@dynamic hasSplit, split;
@dynamic hasStrips, strips;
@dynamic hasWheel, wheel;
@dynamic hasWipe, wipe;
@dynamic hasZoom, zoom;
@dynamic hasFly, fly;
@dynamic hasFloat_p, float_p;
@dynamic hasRevolvingdoor, revolvingdoor;
@dynamic hasPivot, pivot;
@dynamic hasTwirl, twirl;
@dynamic hasSwap, swap;
@dynamic hasFlip, flip;
@dynamic hasCube, cube;
@dynamic hasGallery, gallery;
@dynamic hasReveal, reveal;
@dynamic hasGeometric, geometric;
@dynamic hasRipple, ripple;
@dynamic hasGlitter, glitter;
@dynamic hasVortex, vortex;
@dynamic hasPeek, peek;
@dynamic hasSwivel, swivel;
@dynamic hasFadedZoom, fadedZoom;
@dynamic hasPan, pan;
@dynamic hasFerriswheel, ferriswheel;
@dynamic hasConveyor, conveyor;
@dynamic hasRotate, rotate;
@dynamic hasWindow, window;
@dynamic hasOrbit, orbit;
@dynamic hasFlythru, flythru;
@dynamic hasBox, box;
@dynamic hasDoor, door;
@dynamic hasShred, shred;
@dynamic hasWheelwipe, wheelwipe;
@dynamic hasMeteor, meteor;

typedef struct DisplayAnimation__storage_ {
  uint32_t _has_storage_[2];
  DisplayAnimation_TransitionType type;
  DisplayAnimation_Axis blinds;
  DisplayAnimation_Axis checker;
  DisplayAnimation_Axis comb;
  DisplayAnimation_Direction cover;
  DisplayAnimation_Direction pull;
  DisplayAnimation_Direction push;
  DisplayAnimation_Axis randombar;
  DisplayAnimation_Direction strips;
  int32_t wheel;
  DisplayAnimation_Direction wipe;
  DisplayAnimation_TransitionDirection zoom;
  DisplayAnimation_Direction fly;
  DisplayAnimation_Direction float_p;
  DisplayAnimation_Direction revolvingdoor;
  DisplayAnimation_Direction pivot;
  DisplayAnimation_RotateDirection twirl;
  DisplayAnimation_Direction swap;
  DisplayAnimation_Direction flip;
  DisplayAnimation_Direction cube;
  DisplayAnimation_Direction gallery;
  DisplayAnimation_Direction ripple;
  DisplayAnimation_Direction vortex;
  DisplayAnimation_Direction peek;
  DisplayAnimation_Axis swivel;
  DisplayAnimation_TransitionDirection fadedZoom;
  DisplayAnimation_Direction pan;
  DisplayAnimation_Direction ferriswheel;
  DisplayAnimation_Direction conveyor;
  DisplayAnimation_Direction rotate;
  DisplayAnimation_Axis window;
  DisplayAnimation_Direction orbit;
  DisplayAnimation_Direction box;
  DisplayAnimation_Axis door;
  DisplayAnimation_Direction meteor;
  DisplayAnimation_TransBlack *cut;
  DisplayAnimation_TransBlack *fade;
  DisplayAnimation_Split *split;
  DisplayAnimation_Reveal *reveal;
  DisplayAnimation_Geometric *geometric;
  DisplayAnimation_Glitter *glitter;
  DisplayAnimation_FlyThru *flythru;
  DisplayAnimation_Shred *shred;
  DisplayAnimation_WheelWipe *wheelwipe;
} DisplayAnimation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionType_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blinds",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Blinds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, blinds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "checker",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Checker,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, checker),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "comb",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Comb,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, comb),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cover",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Cover,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, cover),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cut",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_TransBlack),
        .number = DisplayAnimation_FieldNumber_Cut,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, cut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fade",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_TransBlack),
        .number = DisplayAnimation_FieldNumber_Fade,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, fade),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pull",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Pull,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, pull),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "push",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Push,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, push),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "randombar",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Randombar,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, randombar),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "split",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_Split),
        .number = DisplayAnimation_FieldNumber_Split,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, split),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strips",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Strips,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, strips),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wheel",
        .dataTypeSpecific.className = NULL,
        .number = DisplayAnimation_FieldNumber_Wheel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, wheel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wipe",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Wipe,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, wipe),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "zoom",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Zoom,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, zoom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fly",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Fly,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, fly),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "float_p",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Float_p,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, float_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "revolvingdoor",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Revolvingdoor,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, revolvingdoor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pivot",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Pivot,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, pivot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "twirl",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_RotateDirection_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Twirl,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, twirl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "swap",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Swap,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, swap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "flip",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Flip,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, flip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cube",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Cube,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, cube),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gallery",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Gallery,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, gallery),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reveal",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_Reveal),
        .number = DisplayAnimation_FieldNumber_Reveal,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, reveal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "geometric",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_Geometric),
        .number = DisplayAnimation_FieldNumber_Geometric,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, geometric),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ripple",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Ripple,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, ripple),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "glitter",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_Glitter),
        .number = DisplayAnimation_FieldNumber_Glitter,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, glitter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vortex",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Vortex,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, vortex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "peek",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Peek,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, peek),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "swivel",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Swivel,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, swivel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fadedZoom",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_FadedZoom,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, fadedZoom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pan",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Pan,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, pan),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ferriswheel",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Ferriswheel,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, ferriswheel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "conveyor",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Conveyor,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, conveyor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rotate",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Rotate,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, rotate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "window",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Window,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, window),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "orbit",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Orbit,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, orbit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "flythru",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_FlyThru),
        .number = DisplayAnimation_FieldNumber_Flythru,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, flythru),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "box",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Box,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, box),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "door",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Door,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, door),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shred",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_Shred),
        .number = DisplayAnimation_FieldNumber_Shred,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, shred),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wheelwipe",
        .dataTypeSpecific.className = GPBStringifySymbol(DisplayAnimation_WheelWipe),
        .number = DisplayAnimation_FieldNumber_Wheelwipe,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, wheelwipe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meteor",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_FieldNumber_Meteor,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(DisplayAnimation__storage_, meteor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001 \t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum DisplayAnimation_TransitionType

GPBEnumDescriptor *DisplayAnimation_TransitionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Blinds\000Checkers\000Circle\000Comb\000Cover\000C"
        "ut\000Diamond\000Dissolve\000Fade\000Newsflash\000Plus\000"
        "Pull\000Push\000Random\000Randombar\000Split\000Strips\000"
        "Wedge\000Wheel\000Wipe\000Zoom\000Fly\000Float\000Appear\000R"
        "evolvingdoor\000Pivot\000Twirl\000Swap\000Flip\000Cube\000"
        "Gallery\000Fall\000Reveal\000Geometric\000Flash\000Ripp"
        "le\000Honeycomb\000Glitter\000Vortex\000Peek\000ExpandO"
        "rContract\000FadedSwivel\000FadedZoom\000CenterRe"
        "volve\000GrowOrShrinkAndTurn\000RiseupSinkdown"
        "\000Spinner\000Boomer\000Bounce\000Credits\000CurveUpOr"
        "Down\000PinWheel\000Spiral\000Swivel\000Whip\000CurvyFl"
        "oat\000Drop\000Pan\000Ferriswheel\000Conveyor\000Rotate"
        "\000Window\000Orbit\000Flythru\000Box\000Door\000Shred\000Whe"
        "elWipe\000Meteor\000";
    static const int32_t values[] = {
        DisplayAnimation_TransitionType_None,
        DisplayAnimation_TransitionType_Blinds,
        DisplayAnimation_TransitionType_Checkers,
        DisplayAnimation_TransitionType_Circle,
        DisplayAnimation_TransitionType_Comb,
        DisplayAnimation_TransitionType_Cover,
        DisplayAnimation_TransitionType_Cut,
        DisplayAnimation_TransitionType_Diamond,
        DisplayAnimation_TransitionType_Dissolve,
        DisplayAnimation_TransitionType_Fade,
        DisplayAnimation_TransitionType_Newsflash,
        DisplayAnimation_TransitionType_Plus,
        DisplayAnimation_TransitionType_Pull,
        DisplayAnimation_TransitionType_Push,
        DisplayAnimation_TransitionType_Random,
        DisplayAnimation_TransitionType_Randombar,
        DisplayAnimation_TransitionType_Split,
        DisplayAnimation_TransitionType_Strips,
        DisplayAnimation_TransitionType_Wedge,
        DisplayAnimation_TransitionType_Wheel,
        DisplayAnimation_TransitionType_Wipe,
        DisplayAnimation_TransitionType_Zoom,
        DisplayAnimation_TransitionType_Fly,
        DisplayAnimation_TransitionType_Float,
        DisplayAnimation_TransitionType_Appear,
        DisplayAnimation_TransitionType_Revolvingdoor,
        DisplayAnimation_TransitionType_Pivot,
        DisplayAnimation_TransitionType_Twirl,
        DisplayAnimation_TransitionType_Swap,
        DisplayAnimation_TransitionType_Flip,
        DisplayAnimation_TransitionType_Cube,
        DisplayAnimation_TransitionType_Gallery,
        DisplayAnimation_TransitionType_Fall,
        DisplayAnimation_TransitionType_Reveal,
        DisplayAnimation_TransitionType_Geometric,
        DisplayAnimation_TransitionType_Flash,
        DisplayAnimation_TransitionType_Ripple,
        DisplayAnimation_TransitionType_Honeycomb,
        DisplayAnimation_TransitionType_Glitter,
        DisplayAnimation_TransitionType_Vortex,
        DisplayAnimation_TransitionType_Peek,
        DisplayAnimation_TransitionType_ExpandOrContract,
        DisplayAnimation_TransitionType_FadedSwivel,
        DisplayAnimation_TransitionType_FadedZoom,
        DisplayAnimation_TransitionType_CenterRevolve,
        DisplayAnimation_TransitionType_GrowOrShrinkAndTurn,
        DisplayAnimation_TransitionType_RiseupSinkdown,
        DisplayAnimation_TransitionType_Spinner,
        DisplayAnimation_TransitionType_Boomer,
        DisplayAnimation_TransitionType_Bounce,
        DisplayAnimation_TransitionType_Credits,
        DisplayAnimation_TransitionType_CurveUpOrDown,
        DisplayAnimation_TransitionType_PinWheel,
        DisplayAnimation_TransitionType_Spiral,
        DisplayAnimation_TransitionType_Swivel,
        DisplayAnimation_TransitionType_Whip,
        DisplayAnimation_TransitionType_CurvyFloat,
        DisplayAnimation_TransitionType_Drop,
        DisplayAnimation_TransitionType_Pan,
        DisplayAnimation_TransitionType_Ferriswheel,
        DisplayAnimation_TransitionType_Conveyor,
        DisplayAnimation_TransitionType_Rotate,
        DisplayAnimation_TransitionType_Window,
        DisplayAnimation_TransitionType_Orbit,
        DisplayAnimation_TransitionType_Flythru,
        DisplayAnimation_TransitionType_Box,
        DisplayAnimation_TransitionType_Door,
        DisplayAnimation_TransitionType_Shred,
        DisplayAnimation_TransitionType_WheelWipe,
        DisplayAnimation_TransitionType_Meteor,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_TransitionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_TransitionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_TransitionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_TransitionType_None:
    case DisplayAnimation_TransitionType_Blinds:
    case DisplayAnimation_TransitionType_Checkers:
    case DisplayAnimation_TransitionType_Circle:
    case DisplayAnimation_TransitionType_Comb:
    case DisplayAnimation_TransitionType_Cover:
    case DisplayAnimation_TransitionType_Cut:
    case DisplayAnimation_TransitionType_Diamond:
    case DisplayAnimation_TransitionType_Dissolve:
    case DisplayAnimation_TransitionType_Fade:
    case DisplayAnimation_TransitionType_Newsflash:
    case DisplayAnimation_TransitionType_Plus:
    case DisplayAnimation_TransitionType_Pull:
    case DisplayAnimation_TransitionType_Push:
    case DisplayAnimation_TransitionType_Random:
    case DisplayAnimation_TransitionType_Randombar:
    case DisplayAnimation_TransitionType_Split:
    case DisplayAnimation_TransitionType_Strips:
    case DisplayAnimation_TransitionType_Wedge:
    case DisplayAnimation_TransitionType_Wheel:
    case DisplayAnimation_TransitionType_Wipe:
    case DisplayAnimation_TransitionType_Zoom:
    case DisplayAnimation_TransitionType_Fly:
    case DisplayAnimation_TransitionType_Float:
    case DisplayAnimation_TransitionType_Appear:
    case DisplayAnimation_TransitionType_Revolvingdoor:
    case DisplayAnimation_TransitionType_Pivot:
    case DisplayAnimation_TransitionType_Twirl:
    case DisplayAnimation_TransitionType_Swap:
    case DisplayAnimation_TransitionType_Flip:
    case DisplayAnimation_TransitionType_Cube:
    case DisplayAnimation_TransitionType_Gallery:
    case DisplayAnimation_TransitionType_Fall:
    case DisplayAnimation_TransitionType_Reveal:
    case DisplayAnimation_TransitionType_Geometric:
    case DisplayAnimation_TransitionType_Flash:
    case DisplayAnimation_TransitionType_Ripple:
    case DisplayAnimation_TransitionType_Honeycomb:
    case DisplayAnimation_TransitionType_Glitter:
    case DisplayAnimation_TransitionType_Vortex:
    case DisplayAnimation_TransitionType_Peek:
    case DisplayAnimation_TransitionType_ExpandOrContract:
    case DisplayAnimation_TransitionType_FadedSwivel:
    case DisplayAnimation_TransitionType_FadedZoom:
    case DisplayAnimation_TransitionType_CenterRevolve:
    case DisplayAnimation_TransitionType_GrowOrShrinkAndTurn:
    case DisplayAnimation_TransitionType_RiseupSinkdown:
    case DisplayAnimation_TransitionType_Spinner:
    case DisplayAnimation_TransitionType_Boomer:
    case DisplayAnimation_TransitionType_Bounce:
    case DisplayAnimation_TransitionType_Credits:
    case DisplayAnimation_TransitionType_CurveUpOrDown:
    case DisplayAnimation_TransitionType_PinWheel:
    case DisplayAnimation_TransitionType_Spiral:
    case DisplayAnimation_TransitionType_Swivel:
    case DisplayAnimation_TransitionType_Whip:
    case DisplayAnimation_TransitionType_CurvyFloat:
    case DisplayAnimation_TransitionType_Drop:
    case DisplayAnimation_TransitionType_Pan:
    case DisplayAnimation_TransitionType_Ferriswheel:
    case DisplayAnimation_TransitionType_Conveyor:
    case DisplayAnimation_TransitionType_Rotate:
    case DisplayAnimation_TransitionType_Window:
    case DisplayAnimation_TransitionType_Orbit:
    case DisplayAnimation_TransitionType_Flythru:
    case DisplayAnimation_TransitionType_Box:
    case DisplayAnimation_TransitionType_Door:
    case DisplayAnimation_TransitionType_Shred:
    case DisplayAnimation_TransitionType_WheelWipe:
    case DisplayAnimation_TransitionType_Meteor:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DisplayAnimation_Axis

GPBEnumDescriptor *DisplayAnimation_Axis_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Hor\000Ver\000";
    static const int32_t values[] = {
        DisplayAnimation_Axis_Hor,
        DisplayAnimation_Axis_Ver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_Axis)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_Axis_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_Axis_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_Axis_Hor:
    case DisplayAnimation_Axis_Ver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DisplayAnimation_Direction

GPBEnumDescriptor *DisplayAnimation_Direction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Left\000Down\000Right\000Up\000LeftDown\000LeftUp\000Right"
        "Down\000RightUp\000Center\000";
    static const int32_t values[] = {
        DisplayAnimation_Direction_Left,
        DisplayAnimation_Direction_Down,
        DisplayAnimation_Direction_Right,
        DisplayAnimation_Direction_Up,
        DisplayAnimation_Direction_LeftDown,
        DisplayAnimation_Direction_LeftUp,
        DisplayAnimation_Direction_RightDown,
        DisplayAnimation_Direction_RightUp,
        DisplayAnimation_Direction_Center,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_Direction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_Direction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_Direction_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_Direction_Left:
    case DisplayAnimation_Direction_Down:
    case DisplayAnimation_Direction_Right:
    case DisplayAnimation_Direction_Up:
    case DisplayAnimation_Direction_LeftDown:
    case DisplayAnimation_Direction_LeftUp:
    case DisplayAnimation_Direction_RightDown:
    case DisplayAnimation_Direction_RightUp:
    case DisplayAnimation_Direction_Center:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DisplayAnimation_TransitionDirection

GPBEnumDescriptor *DisplayAnimation_TransitionDirection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "In\000Out\000InSlightly\000OutSlightly\000InFromCent"
        "er\000OutFromBottom\000OutToCenter\000InToBottom\000";
    static const int32_t values[] = {
        DisplayAnimation_TransitionDirection_In,
        DisplayAnimation_TransitionDirection_Out,
        DisplayAnimation_TransitionDirection_InSlightly,
        DisplayAnimation_TransitionDirection_OutSlightly,
        DisplayAnimation_TransitionDirection_InFromCenter,
        DisplayAnimation_TransitionDirection_OutFromBottom,
        DisplayAnimation_TransitionDirection_OutToCenter,
        DisplayAnimation_TransitionDirection_InToBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_TransitionDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_TransitionDirection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_TransitionDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_TransitionDirection_In:
    case DisplayAnimation_TransitionDirection_Out:
    case DisplayAnimation_TransitionDirection_InSlightly:
    case DisplayAnimation_TransitionDirection_OutSlightly:
    case DisplayAnimation_TransitionDirection_InFromCenter:
    case DisplayAnimation_TransitionDirection_OutFromBottom:
    case DisplayAnimation_TransitionDirection_OutToCenter:
    case DisplayAnimation_TransitionDirection_InToBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DisplayAnimation_RotateDirection

GPBEnumDescriptor *DisplayAnimation_RotateDirection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Clockwise\000AntiClockwise\000";
    static const int32_t values[] = {
        DisplayAnimation_RotateDirection_Clockwise,
        DisplayAnimation_RotateDirection_AntiClockwise,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_RotateDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_RotateDirection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_RotateDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_RotateDirection_Clockwise:
    case DisplayAnimation_RotateDirection_AntiClockwise:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DisplayAnimation_ObjectType

GPBEnumDescriptor *DisplayAnimation_ObjectType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Strip\000Particle\000";
    static const int32_t values[] = {
        DisplayAnimation_ObjectType_Strip,
        DisplayAnimation_ObjectType_Particle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DisplayAnimation_ObjectType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DisplayAnimation_ObjectType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DisplayAnimation_ObjectType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DisplayAnimation_ObjectType_Strip:
    case DisplayAnimation_ObjectType_Particle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DisplayAnimation_TransBlack

@implementation DisplayAnimation_TransBlack

@dynamic hasThruBlack, thruBlack;

typedef struct DisplayAnimation_TransBlack__storage_ {
  uint32_t _has_storage_[1];
} DisplayAnimation_TransBlack__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thruBlack",
        .dataTypeSpecific.className = NULL,
        .number = DisplayAnimation_TransBlack_FieldNumber_ThruBlack,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_TransBlack class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_TransBlack__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_Split

@implementation DisplayAnimation_Split

@dynamic hasDir, dir;
@dynamic hasTransDir, transDir;

typedef struct DisplayAnimation_Split__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_Axis dir;
  DisplayAnimation_TransitionDirection transDir;
} DisplayAnimation_Split__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dir",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Axis_EnumDescriptor,
        .number = DisplayAnimation_Split_FieldNumber_Dir,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation_Split__storage_, dir),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transDir",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .number = DisplayAnimation_Split_FieldNumber_TransDir,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayAnimation_Split__storage_, transDir),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_Split class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_Split__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_Reveal

@implementation DisplayAnimation_Reveal

@dynamic hasDir, dir;
@dynamic hasThruBlack, thruBlack;

typedef struct DisplayAnimation_Reveal__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_Direction dir;
} DisplayAnimation_Reveal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dir",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .number = DisplayAnimation_Reveal_FieldNumber_Dir,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation_Reveal__storage_, dir),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "thruBlack",
        .dataTypeSpecific.className = NULL,
        .number = DisplayAnimation_Reveal_FieldNumber_ThruBlack,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_Reveal class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_Reveal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_Geometric

@implementation DisplayAnimation_Geometric

@dynamic hasGeom, geom;
@dynamic hasTransDir, transDir;

typedef struct DisplayAnimation_Geometric__storage_ {
  uint32_t _has_storage_[1];
  PresetShapeGeometry geom;
  DisplayAnimation_TransitionDirection transDir;
} DisplayAnimation_Geometric__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PresetShapeGeometry_Rect,
        .core.name = "geom",
        .core.dataTypeSpecific.enumDescFunc = PresetShapeGeometry_EnumDescriptor,
        .core.number = DisplayAnimation_Geometric_FieldNumber_Geom,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(DisplayAnimation_Geometric__storage_, geom),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = DisplayAnimation_TransitionDirection_In,
        .core.name = "transDir",
        .core.dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .core.number = DisplayAnimation_Geometric_FieldNumber_TransDir,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(DisplayAnimation_Geometric__storage_, transDir),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_Geometric class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(DisplayAnimation_Geometric__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_Glitter

@implementation DisplayAnimation_Glitter

@dynamic hasDir, dir;
@dynamic hasPattern, pattern;

typedef struct DisplayAnimation_Glitter__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_Direction dir;
  PresetShapeGeometry pattern;
} DisplayAnimation_Glitter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = DisplayAnimation_Direction_Left,
        .core.name = "dir",
        .core.dataTypeSpecific.enumDescFunc = DisplayAnimation_Direction_EnumDescriptor,
        .core.number = DisplayAnimation_Glitter_FieldNumber_Dir,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(DisplayAnimation_Glitter__storage_, dir),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = PresetShapeGeometry_Rect,
        .core.name = "pattern",
        .core.dataTypeSpecific.enumDescFunc = PresetShapeGeometry_EnumDescriptor,
        .core.number = DisplayAnimation_Glitter_FieldNumber_Pattern,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(DisplayAnimation_Glitter__storage_, pattern),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_Glitter class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(DisplayAnimation_Glitter__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_FlyThru

@implementation DisplayAnimation_FlyThru

@dynamic hasTransDir, transDir;
@dynamic hasBounce, bounce;

typedef struct DisplayAnimation_FlyThru__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_TransitionDirection transDir;
} DisplayAnimation_FlyThru__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transDir",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .number = DisplayAnimation_FlyThru_FieldNumber_TransDir,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation_FlyThru__storage_, transDir),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bounce",
        .dataTypeSpecific.className = NULL,
        .number = DisplayAnimation_FlyThru_FieldNumber_Bounce,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_FlyThru class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_FlyThru__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_Shred

@implementation DisplayAnimation_Shred

@dynamic hasTransDir, transDir;
@dynamic hasType, type;

typedef struct DisplayAnimation_Shred__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_TransitionDirection transDir;
  DisplayAnimation_ObjectType type;
} DisplayAnimation_Shred__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transDir",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_TransitionDirection_EnumDescriptor,
        .number = DisplayAnimation_Shred_FieldNumber_TransDir,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation_Shred__storage_, transDir),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_ObjectType_EnumDescriptor,
        .number = DisplayAnimation_Shred_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayAnimation_Shred__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_Shred class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_Shred__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayAnimation_WheelWipe

@implementation DisplayAnimation_WheelWipe

@dynamic hasRot, rot;
@dynamic hasSpokes, spokes;

typedef struct DisplayAnimation_WheelWipe__storage_ {
  uint32_t _has_storage_[1];
  DisplayAnimation_RotateDirection rot;
  int32_t spokes;
} DisplayAnimation_WheelWipe__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rot",
        .dataTypeSpecific.enumDescFunc = DisplayAnimation_RotateDirection_EnumDescriptor,
        .number = DisplayAnimation_WheelWipe_FieldNumber_Rot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayAnimation_WheelWipe__storage_, rot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "spokes",
        .dataTypeSpecific.className = NULL,
        .number = DisplayAnimation_WheelWipe_FieldNumber_Spokes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayAnimation_WheelWipe__storage_, spokes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayAnimation_WheelWipe class]
                                     rootClass:[DisplayanimationRoot class]
                                          file:DisplayanimationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayAnimation_WheelWipe__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DisplayAnimation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
