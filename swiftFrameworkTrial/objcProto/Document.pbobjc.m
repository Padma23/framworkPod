// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: document.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Document.pbobjc.h"
 #import "Pagesetup.pbobjc.h"
 #import "Parastyle.pbobjc.h"
 #import "Color.pbobjc.h"
 #import "Relationship.pbobjc.h"
 #import "Font.pbobjc.h"
 #import "Picproperties.pbobjc.h"
 #import "Customfile.pbobjc.h"
 #import "Tablestyle.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - DocumentRoot

@implementation DocumentRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DocumentRoot_FileDescriptor

static GPBFileDescriptor *DocumentRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Document

@implementation Document

@dynamic mastersArray, mastersArray_Count;
@dynamic slidesArray, slidesArray_Count;
@dynamic layoutsArray, layoutsArray_Count;
@dynamic hasSlideSetup, slideSetup;
@dynamic defTextStylesArray, defTextStylesArray_Count;
@dynamic picturesArray, picturesArray_Count;
@dynamic customShowArray, customShowArray_Count;
@dynamic hasSlideShow, slideShow;
@dynamic hasShowProps, showProps;
@dynamic sessionPropsArray, sessionPropsArray_Count;
@dynamic encryptedPictureKeysArray, encryptedPictureKeysArray_Count;
@dynamic webFontsArray, webFontsArray_Count;
@dynamic picPropsArray, picPropsArray_Count;
@dynamic filesArray, filesArray_Count;
@dynamic linkedFilesArray, linkedFilesArray_Count;
@dynamic tableStylesArray, tableStylesArray_Count;
@dynamic hasSpellCheckProps, spellCheckProps;

typedef struct Document__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mastersArray;
  NSMutableArray *slidesArray;
  NSMutableArray *layoutsArray;
  PageSetup *slideSetup;
  NSMutableArray *defTextStylesArray;
  NSMutableArray *picturesArray;
  NSMutableArray *customShowArray;
  Document_SlideShow *slideShow;
  Document_SlideShowProperties *showProps;
  NSMutableArray *sessionPropsArray;
  NSMutableArray *encryptedPictureKeysArray;
  NSMutableArray *webFontsArray;
  NSMutableArray *picPropsArray;
  NSMutableArray *filesArray;
  NSMutableArray *linkedFilesArray;
  NSMutableArray *tableStylesArray;
  Document_SpellCheckProps *spellCheckProps;
} Document__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mastersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Relationship),
        .number = Document_FieldNumber_MastersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, mastersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slidesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Relationship),
        .number = Document_FieldNumber_SlidesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, slidesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layoutsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_Layouts),
        .number = Document_FieldNumber_LayoutsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, layoutsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideSetup",
        .dataTypeSpecific.className = GPBStringifySymbol(PageSetup),
        .number = Document_FieldNumber_SlideSetup,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document__storage_, slideSetup),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defTextStylesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ParaStyle),
        .number = Document_FieldNumber_DefTextStylesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, defTextStylesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "picturesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Relationship),
        .number = Document_FieldNumber_PicturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, picturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customShowArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_CustomShow),
        .number = Document_FieldNumber_CustomShowArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, customShowArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideShow",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SlideShow),
        .number = Document_FieldNumber_SlideShow,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document__storage_, slideShow),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showProps",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SlideShowProperties),
        .number = Document_FieldNumber_ShowProps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Document__storage_, showProps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionPropsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SessionProps),
        .number = Document_FieldNumber_SessionPropsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, sessionPropsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "encryptedPictureKeysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SessionProps),
        .number = Document_FieldNumber_EncryptedPictureKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, encryptedPictureKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webFontsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Font),
        .number = Document_FieldNumber_WebFontsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, webFontsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "picPropsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PicProperties),
        .number = Document_FieldNumber_PicPropsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, picPropsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "filesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CustomFile),
        .number = Document_FieldNumber_FilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, filesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linkedFilesArray",
        .dataTypeSpecific.className = NULL,
        .number = Document_FieldNumber_LinkedFilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, linkedFilesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tableStylesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_TableStyleDefinition),
        .number = Document_FieldNumber_TableStylesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document__storage_, tableStylesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spellCheckProps",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SpellCheckProps),
        .number = Document_FieldNumber_SpellCheckProps,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Document__storage_, spellCheckProps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\004\n\000\005\000defTextStyles\000\007\000customShow\000\010\t\000\t\t\000\n"
        "\000sessionProps\000\013\000encryptedPictureKeys\000\014\000w"
        "ebFonts\000\r\000picProps\000\017\000linkedFiles\000\020\000table"
        "Styles\000\021\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_Layouts

@implementation Document_Layouts

@dynamic keysArray, keysArray_Count;

typedef struct Document_Layouts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysArray;
} Document_Layouts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Relationship),
        .number = Document_Layouts_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document_Layouts__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_Layouts class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_Layouts__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_CustomShow

@implementation Document_CustomShow

@dynamic hasId_p, id_p;
@dynamic hasName, name;
@dynamic slidesArray, slidesArray_Count;

typedef struct Document_CustomShow__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  NSMutableArray *slidesArray;
} Document_CustomShow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Document_CustomShow_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_CustomShow__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Document_CustomShow_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document_CustomShow__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slidesArray",
        .dataTypeSpecific.className = NULL,
        .number = Document_CustomShow_FieldNumber_SlidesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document_CustomShow__storage_, slidesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_CustomShow class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_CustomShow__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_SlideShow

@implementation Document_SlideShow

@dynamic hasType, type;
@dynamic hasRange, range;
@dynamic hasCustomShowId, customShowId;

typedef struct Document_SlideShow__storage_ {
  uint32_t _has_storage_[1];
  Document_SlideShow_SlideShowType type;
  Document_SlideShow_SlideRange *range;
  NSString *customShowId;
} Document_SlideShow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Document_SlideShow_SlideShowType_EnumDescriptor,
        .number = Document_SlideShow_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_SlideShow__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "range",
        .dataTypeSpecific.className = GPBStringifySymbol(Document_SlideShow_SlideRange),
        .number = Document_SlideShow_FieldNumber_Range,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document_SlideShow__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customShowId",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShow_FieldNumber_CustomShowId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Document_SlideShow__storage_, customShowId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_SlideShow class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_SlideShow__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Document_SlideShow_SlideShowType

GPBEnumDescriptor *Document_SlideShow_SlideShowType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "All\000Range\000Custom\000";
    static const int32_t values[] = {
        Document_SlideShow_SlideShowType_All,
        Document_SlideShow_SlideShowType_Range,
        Document_SlideShow_SlideShowType_Custom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Document_SlideShow_SlideShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Document_SlideShow_SlideShowType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Document_SlideShow_SlideShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Document_SlideShow_SlideShowType_All:
    case Document_SlideShow_SlideShowType_Range:
    case Document_SlideShow_SlideShowType_Custom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Document_SlideShow_SlideRange

@implementation Document_SlideShow_SlideRange

@dynamic hasStart, start;
@dynamic hasEnd, end;

typedef struct Document_SlideShow_SlideRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t start;
  int32_t end;
} Document_SlideShow_SlideRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShow_SlideRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_SlideShow_SlideRange__storage_, start),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShow_SlideRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document_SlideShow_SlideRange__storage_, end),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_SlideShow_SlideRange class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_SlideShow_SlideRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document_SlideShow)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_SlideShowProperties

@implementation Document_SlideShowProperties

@dynamic hasLoop, loop;
@dynamic hasNoTransition, noTransition;
@dynamic hasNoAnimation, noAnimation;
@dynamic hasNoTimings, noTimings;
@dynamic hasPen, pen;

typedef struct Document_SlideShowProperties__storage_ {
  uint32_t _has_storage_[1];
  Color *pen;
} Document_SlideShowProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loop",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShowProperties_FieldNumber_Loop,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noTransition",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShowProperties_FieldNumber_NoTransition,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noAnimation",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShowProperties_FieldNumber_NoAnimation,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noTimings",
        .dataTypeSpecific.className = NULL,
        .number = Document_SlideShowProperties_FieldNumber_NoTimings,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pen",
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .number = Document_SlideShowProperties_FieldNumber_Pen,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Document_SlideShowProperties__storage_, pen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_SlideShowProperties class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_SlideShowProperties__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\014\000\003\013\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_SessionProps

@implementation Document_SessionProps

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct Document_SessionProps__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} Document_SessionProps__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = Document_SessionProps_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_SessionProps__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Document_SessionProps_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document_SessionProps__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_SessionProps class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_SessionProps__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_TableStyleDefinition

@implementation Document_TableStyleDefinition

@dynamic hasStyle, style;
@dynamic hasUsed, used;

typedef struct Document_TableStyleDefinition__storage_ {
  uint32_t _has_storage_[1];
  int32_t used;
  TableStyle *style;
} Document_TableStyleDefinition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.className = GPBStringifySymbol(TableStyle),
        .number = Document_TableStyleDefinition_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_TableStyleDefinition__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "used",
        .dataTypeSpecific.className = NULL,
        .number = Document_TableStyleDefinition_FieldNumber_Used,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Document_TableStyleDefinition__storage_, used),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_TableStyleDefinition class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_TableStyleDefinition__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Document_SpellCheckProps

@implementation Document_SpellCheckProps

@dynamic ignoredWordsArray, ignoredWordsArray_Count;
@dynamic hasSpellCheckedLang, spellCheckedLang;

typedef struct Document_SpellCheckProps__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *ignoredWordsArray;
  NSString *spellCheckedLang;
} Document_SpellCheckProps__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ignoredWordsArray",
        .dataTypeSpecific.className = NULL,
        .number = Document_SpellCheckProps_FieldNumber_IgnoredWordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Document_SpellCheckProps__storage_, ignoredWordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spellCheckedLang",
        .dataTypeSpecific.className = NULL,
        .number = Document_SpellCheckProps_FieldNumber_SpellCheckedLang,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Document_SpellCheckProps__storage_, spellCheckedLang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Document_SpellCheckProps class]
                                     rootClass:[DocumentRoot class]
                                          file:DocumentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Document_SpellCheckProps__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000ignoredWords\000\002\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Document)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
