// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fill.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Fill.pbobjc.h"
 #import "Color.pbobjc.h"
 #import "Offset.pbobjc.h"
 #import "Scale.pbobjc.h"
 #import "Picturevalue.pbobjc.h"
 #import "Pictureproperties.pbobjc.h"
 #import "Presetprops.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - FillRoot

@implementation FillRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - FillRoot_FileDescriptor

static GPBFileDescriptor *FillRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.adventnet.zoho.show.slides"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Fill

@implementation Fill

@dynamic hasType, type;
@dynamic hasSolid, solid;
@dynamic hasGradient, gradient;
@dynamic hasPict, pict;
@dynamic hasGrp, grp;
@dynamic hasPreset, preset;

typedef struct Fill__storage_ {
  uint32_t _has_storage_[1];
  Fill_FillType type;
  PresetProps preset;
  Fill_SolidFill *solid;
  Fill_GradientFill *gradient;
  Fill_PictureFill *pict;
} Fill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = Fill_FillType_Solid,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = Fill_FillType_EnumDescriptor,
        .core.number = Fill_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Fill__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "solid",
        .core.dataTypeSpecific.className = GPBStringifySymbol(Fill_SolidFill),
        .core.number = Fill_FieldNumber_Solid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Fill__storage_, solid),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "gradient",
        .core.dataTypeSpecific.className = GPBStringifySymbol(Fill_GradientFill),
        .core.number = Fill_FieldNumber_Gradient,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Fill__storage_, gradient),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "pict",
        .core.dataTypeSpecific.className = GPBStringifySymbol(Fill_PictureFill),
        .core.number = Fill_FieldNumber_Pict,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Fill__storage_, pict),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "grp",
        .core.dataTypeSpecific.className = NULL,
        .core.number = Fill_FieldNumber_Grp,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = PresetProps_Preset1,
        .core.name = "preset",
        .core.dataTypeSpecific.enumDescFunc = PresetProps_EnumDescriptor,
        .core.number = Fill_FieldNumber_Preset,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Fill__storage_, preset),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Fill__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Fill_FillType

GPBEnumDescriptor *Fill_FillType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Solid\000Gradient\000Pict\000Grp\000";
    static const int32_t values[] = {
        Fill_FillType_None,
        Fill_FillType_Solid,
        Fill_FillType_Gradient,
        Fill_FillType_Pict,
        Fill_FillType_Grp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Fill_FillType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Fill_FillType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Fill_FillType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Fill_FillType_None:
    case Fill_FillType_Solid:
    case Fill_FillType_Gradient:
    case Fill_FillType_Pict:
    case Fill_FillType_Grp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Fill_SolidFill

@implementation Fill_SolidFill

@dynamic hasColor, color;

typedef struct Fill_SolidFill__storage_ {
  uint32_t _has_storage_[1];
  Color *color;
} Fill_SolidFill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .number = Fill_SolidFill_FieldNumber_Color,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_SolidFill__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_SolidFill class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_SolidFill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fill_GradientFill

@implementation Fill_GradientFill

@dynamic hasType, type;
@dynamic hasRotate, rotate;
@dynamic stopsArray, stopsArray_Count;
@dynamic hasRadial, radial;
@dynamic hasRect, rect;
@dynamic hasLinear, linear;

typedef struct Fill_GradientFill__storage_ {
  uint32_t _has_storage_[1];
  Fill_GradientFill_GradientFillType type;
  int32_t rotate;
  NSMutableArray *stopsArray;
  Fill_GradientFill_GradientProperties *radial;
  Fill_GradientFill_GradientProperties *rect;
  Fill_GradientFill_GradientProperties *linear;
} Fill_GradientFill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Fill_GradientFill_GradientFillType_EnumDescriptor,
        .number = Fill_GradientFill_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rotate",
        .dataTypeSpecific.className = NULL,
        .number = Fill_GradientFill_FieldNumber_Rotate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, rotate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stopsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_GradientFill_Stop),
        .number = Fill_GradientFill_FieldNumber_StopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, stopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "radial",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_GradientFill_GradientProperties),
        .number = Fill_GradientFill_FieldNumber_Radial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, radial),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_GradientFill_GradientProperties),
        .number = Fill_GradientFill_FieldNumber_Rect,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linear",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_GradientFill_GradientProperties),
        .number = Fill_GradientFill_FieldNumber_Linear,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Fill_GradientFill__storage_, linear),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_GradientFill class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_GradientFill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Fill_GradientFill_GradientFillType

GPBEnumDescriptor *Fill_GradientFill_GradientFillType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Linear\000Radial\000Rectangular\000Path\000";
    static const int32_t values[] = {
        Fill_GradientFill_GradientFillType_Linear,
        Fill_GradientFill_GradientFillType_Radial,
        Fill_GradientFill_GradientFillType_Rectangular,
        Fill_GradientFill_GradientFillType_Path,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Fill_GradientFill_GradientFillType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Fill_GradientFill_GradientFillType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Fill_GradientFill_GradientFillType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Fill_GradientFill_GradientFillType_Linear:
    case Fill_GradientFill_GradientFillType_Radial:
    case Fill_GradientFill_GradientFillType_Rectangular:
    case Fill_GradientFill_GradientFillType_Path:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Fill_GradientFill_Stop

@implementation Fill_GradientFill_Stop

@dynamic hasColor, color;
@dynamic hasPosition, position;

typedef struct Fill_GradientFill_Stop__storage_ {
  uint32_t _has_storage_[1];
  float position;
  Color *color;
} Fill_GradientFill_Stop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .number = Fill_GradientFill_Stop_FieldNumber_Color,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_GradientFill_Stop__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = Fill_GradientFill_Stop_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_GradientFill_Stop__storage_, position),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_GradientFill_Stop class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_GradientFill_Stop__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill_GradientFill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fill_GradientFill_GradientProperties

@implementation Fill_GradientFill_GradientProperties

@dynamic hasFillToRect, fillToRect;
@dynamic hasTileRect, tileRect;
@dynamic hasFliph, fliph;
@dynamic hasFlipv, flipv;
@dynamic hasCornerOffset, cornerOffset;
@dynamic hasRotate, rotate;

typedef struct Fill_GradientFill_GradientProperties__storage_ {
  uint32_t _has_storage_[1];
  int32_t rotate;
  Offset *fillToRect;
  Offset *tileRect;
  Offset *cornerOffset;
} Fill_GradientFill_GradientProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fillToRect",
        .dataTypeSpecific.className = GPBStringifySymbol(Offset),
        .number = Fill_GradientFill_GradientProperties_FieldNumber_FillToRect,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_GradientFill_GradientProperties__storage_, fillToRect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tileRect",
        .dataTypeSpecific.className = GPBStringifySymbol(Offset),
        .number = Fill_GradientFill_GradientProperties_FieldNumber_TileRect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_GradientFill_GradientProperties__storage_, tileRect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fliph",
        .dataTypeSpecific.className = NULL,
        .number = Fill_GradientFill_GradientProperties_FieldNumber_Fliph,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flipv",
        .dataTypeSpecific.className = NULL,
        .number = Fill_GradientFill_GradientProperties_FieldNumber_Flipv,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cornerOffset",
        .dataTypeSpecific.className = GPBStringifySymbol(Offset),
        .number = Fill_GradientFill_GradientProperties_FieldNumber_CornerOffset,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Fill_GradientFill_GradientProperties__storage_, cornerOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rotate",
        .dataTypeSpecific.className = NULL,
        .number = Fill_GradientFill_GradientProperties_FieldNumber_Rotate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Fill_GradientFill_GradientProperties__storage_, rotate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_GradientFill_GradientProperties class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_GradientFill_GradientProperties__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\n\000\002\010\000\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill_GradientFill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fill_PictureFill

@implementation Fill_PictureFill

@dynamic hasValue, value;
@dynamic hasProps, props;
@dynamic hasTransparency, transparency;
@dynamic hasType, type;

typedef struct Fill_PictureFill__storage_ {
  uint32_t _has_storage_[1];
  float transparency;
  PictureValue *value;
  PictureProperties *props;
  Fill_PictureFill_PictureFillType *type;
} Fill_PictureFill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = GPBStringifySymbol(PictureValue),
        .number = Fill_PictureFill_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_PictureFill__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "props",
        .dataTypeSpecific.className = GPBStringifySymbol(PictureProperties),
        .number = Fill_PictureFill_FieldNumber_Props,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_PictureFill__storage_, props),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transparency",
        .dataTypeSpecific.className = NULL,
        .number = Fill_PictureFill_FieldNumber_Transparency,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fill_PictureFill__storage_, transparency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_PictureFill_PictureFillType),
        .number = Fill_PictureFill_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Fill_PictureFill__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_PictureFill class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_PictureFill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fill_PictureFill_PictureFillType

@implementation Fill_PictureFill_PictureFillType

@dynamic hasType, type;
@dynamic hasFrame, frame;
@dynamic hasTile, tile;

typedef struct Fill_PictureFill_PictureFillType__storage_ {
  uint32_t _has_storage_[1];
  Fill_PictureFill_PictureFillType_FillPictureAs type;
  Offset *frame;
  Fill_PictureFill_PictureFillType_Tile *tile;
} Fill_PictureFill_PictureFillType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Fill_PictureFill_PictureFillType_FillPictureAs_EnumDescriptor,
        .number = Fill_PictureFill_PictureFillType_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = GPBStringifySymbol(Offset),
        .number = Fill_PictureFill_PictureFillType_FieldNumber_Frame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tile",
        .dataTypeSpecific.className = GPBStringifySymbol(Fill_PictureFill_PictureFillType_Tile),
        .number = Fill_PictureFill_PictureFillType_FieldNumber_Tile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType__storage_, tile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_PictureFill_PictureFillType class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_PictureFill_PictureFillType__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill_PictureFill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Fill_PictureFill_PictureFillType_FillPictureAs

GPBEnumDescriptor *Fill_PictureFill_PictureFillType_FillPictureAs_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Frame\000Tile\000";
    static const int32_t values[] = {
        Fill_PictureFill_PictureFillType_FillPictureAs_Frame,
        Fill_PictureFill_PictureFillType_FillPictureAs_Tile,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Fill_PictureFill_PictureFillType_FillPictureAs)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Fill_PictureFill_PictureFillType_FillPictureAs_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Fill_PictureFill_PictureFillType_FillPictureAs_IsValidValue(int32_t value__) {
  switch (value__) {
    case Fill_PictureFill_PictureFillType_FillPictureAs_Frame:
    case Fill_PictureFill_PictureFillType_FillPictureAs_Tile:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Fill_PictureFill_PictureFillType_Tile

@implementation Fill_PictureFill_PictureFillType_Tile

@dynamic hasOffsetX, offsetX;
@dynamic hasOffsetY, offsetY;
@dynamic hasScale, scale;

typedef struct Fill_PictureFill_PictureFillType_Tile__storage_ {
  uint32_t _has_storage_[1];
  float offsetX;
  float offsetY;
  Scale *scale;
} Fill_PictureFill_PictureFillType_Tile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offsetX",
        .dataTypeSpecific.className = NULL,
        .number = Fill_PictureFill_PictureFillType_Tile_FieldNumber_OffsetX,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType_Tile__storage_, offsetX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "offsetY",
        .dataTypeSpecific.className = NULL,
        .number = Fill_PictureFill_PictureFillType_Tile_FieldNumber_OffsetY,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType_Tile__storage_, offsetY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "scale",
        .dataTypeSpecific.className = GPBStringifySymbol(Scale),
        .number = Fill_PictureFill_PictureFillType_Tile_FieldNumber_Scale,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fill_PictureFill_PictureFillType_Tile__storage_, scale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fill_PictureFill_PictureFillType_Tile class]
                                     rootClass:[FillRoot class]
                                          file:FillRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fill_PictureFill_PictureFillType_Tile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Fill_PictureFill_PictureFillType)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
